// -----------------------------------------------------------------------------
// Copyright 2015-2024 Patrick NÃ¤f (herzbube@herzbube.ch)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// -----------------------------------------------------------------------------


// Project includes
#import "AutoLayoutUtility.h"
#import "../shared/LayoutManager.h"


@implementation AutoLayoutUtility

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview completely fills @a superview, i.e. that the subview's frame is
/// the same as the superview's bounds. Returns the constraints generated by
/// this method.
// -----------------------------------------------------------------------------
+ (NSArray*) fillSuperview:(UIView*)superview
               withSubview:(UIView*)subview
{
  return [AutoLayoutUtility fillSuperview:superview
                              withSubview:subview
                                  margins:UIEdgeInsetsMake(0, 0, 0, 0)];
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview completely fills @a superview except for the specified margins.
/// Returns the constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) fillSuperview:(UIView*)superview
               withSubview:(UIView*)subview
                   margins:(UIEdgeInsets)margins
{
  NSDictionary* viewsDictionary = [NSDictionary dictionaryWithObject:subview
                                                              forKey:@"subview"];
  NSArray* visualFormats = [NSArray arrayWithObjects:
                            [NSString stringWithFormat:@"H:|-%f-[subview]-%f-|", margins.left, margins.right],
                            [NSString stringWithFormat:@"V:|-%f-[subview]-%f-|", margins.top, margins.bottom],
                            nil];
  return [AutoLayoutUtility installVisualFormats:visualFormats
                                       withViews:viewsDictionary
                                          inView:superview];
}

// -----------------------------------------------------------------------------
/// @brief Creates Auto Layout constraints that completely fill the safe area
/// of @a superview with @a subview. The constraints are added to the closest
/// common ancestor of the two views. Returns the constraints generated by this
/// method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
///
/// In iOS 7 Apple introduced the topLayoutGuide and bottomLayoutGuide
/// properties in UIViewController to describe a screen area that isn't covered
/// by any content (status bar, navigation bar, toolbar, tab bar, etc.) In
/// iOS 11 Apple has deprecated these properties and introduced the safe area.
///
/// Overview article: https://medium.com/rosberryapps/ios-safe-area-ca10e919526f
// -----------------------------------------------------------------------------
+ (NSArray*) fillSafeAreaOfSuperview:(UIView*)superview
                         withSubview:(UIView*)subview
{
  return [AutoLayoutUtility alignFirstView:subview
                            withSecondView:superview
                           onSafeAreaEdges:UIRectEdgeAll];
}

// -----------------------------------------------------------------------------
/// @brief Creates Auto Layout constraints that fill @a superview with
/// @a subview to the edges of @a superview in the direction specified by
/// @a viewEdgesAxis, and to the edges of the safe area of @a superview in the
/// direction specified by @a safeAreaEdgesAxis. The constraints are added to
/// the closest common ancestor of the two views. Returns the constraints
/// generated by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
///
/// @a note This method is a third alternative to the methods
/// fillSuperview:withSubview:() and fillSafeAreaOfSuperview:withSubview:(),
/// both of which fill to their respective boundaries in both horizontal and
/// vertical directions.
// -----------------------------------------------------------------------------
+ (NSArray*) fillSuperview:(UIView*)superview
               withSubview:(UIView*)subview
             viewEdgesAxis:(UILayoutConstraintAxis)viewEdgesAxis
         safeAreaEdgesAxis:(UILayoutConstraintAxis)safeAreaEdgesAxis
{
  UIRectEdge viewEdges = (viewEdgesAxis == UILayoutConstraintAxisHorizontal
                          ? UIRectEdgeLeft | UIRectEdgeRight
                          : UIRectEdgeTop | UIRectEdgeBottom);
  NSArray* viewEdgesConstraints = [AutoLayoutUtility alignFirstView:subview
                                                     withSecondView:superview
                                                            onEdges:viewEdges];

  UIRectEdge safeAreaEdges = (safeAreaEdgesAxis == UILayoutConstraintAxisHorizontal
                              ? UIRectEdgeLeft | UIRectEdgeRight
                              : UIRectEdgeTop | UIRectEdgeBottom);
  NSArray* safeAreaEdgesConstraints = [AutoLayoutUtility alignFirstView:subview
                                                         withSecondView:superview
                                                        onSafeAreaEdges:safeAreaEdges];

  return [viewEdgesConstraints arrayByAddingObjectsFromArray:safeAreaEdgesConstraints];
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview is horizontally and vertically centered in @a superview. Returns
/// the constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) centerSubview:(UIView*)subview inSuperview:(UIView*)superview
{
  NSLayoutConstraint* constraint1 = [AutoLayoutUtility alignFirstView:subview
                                                       withSecondView:superview
                                                          onAttribute:NSLayoutAttributeCenterX
                                                     constraintHolder:superview];
  NSLayoutConstraint* constraint2 = [AutoLayoutUtility alignFirstView:subview
                                                       withSecondView:superview
                                                          onAttribute:NSLayoutAttributeCenterY
                                                     constraintHolder:superview];
  return [NSArray arrayWithObjects:constraint1, constraint2, nil];
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a superview that specifies that
/// @a subview is centered in @a superview along the specified axis. Returns the
/// constraint generated by this method.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) centerSubview:(UIView*)subview
                          inSuperview:(UIView*)superview
                               onAxis:(UILayoutConstraintAxis)axis
{
  NSLayoutAttribute attribute;
  if (UILayoutConstraintAxisHorizontal == axis)
    attribute = NSLayoutAttributeCenterX;
  else
    attribute = NSLayoutAttributeCenterY;
  return [AutoLayoutUtility alignFirstView:subview
                            withSecondView:superview
                               onAttribute:attribute
                          constraintHolder:superview];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute. The constraint is assigned
/// priority @e UILayoutPriorityRequired and is added to @a constraintHolder.
/// Returns the constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute. For instance, if @a attribute is NSLayoutAttributeLeft, then the
/// two views are left-aligned. A little less intuitive: If @a attribute is
/// NSLayoutAttributeWidth or NSLayoutAttributeHeight, then the two views have
/// the same width or height.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                      constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                               onAttribute:attribute
                            withMultiplier:1.0f
                              withConstant:0.0f
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute, with the alignment being
/// modified by @a constant. The constraint is assigned priority
/// @e UILayoutPriorityRequired and is added to @a constraintHolder. Returns
/// the constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute, with @a constant added. For instance, if @a attribute is
/// NSLayoutAttributeLeft, then the two views are left-aligned, with
/// @a firstView additionally shifted to the right or left (depending on whether
/// @a constant is a positive or negative value). A little less intuitive: If
/// @a attribute is NSLayoutAttributeWidth or NSLayoutAttributeHeight, then
/// @a firstView has the same width or height as @a secondView, with @a constant
/// being added to the width or height.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                          withConstant:(CGFloat)constant
                      constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                               onAttribute:attribute
                            withMultiplier:1.0f
                              withConstant:constant
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute, with the alignment being
/// modified by @a constant. The constraint is assigned priority
/// @e UILayoutPriorityRequired and is added to @a constraintHolder. Returns
/// the constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute, but multiplied by @a multiplier. For instance, if @a attribute is
/// NSLayoutAttributeHeight, then @a firstView has the height of @a secondView
/// multiplied by @a multiplier.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                        withMultiplier:(CGFloat)multiplier
                      constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                               onAttribute:attribute
                            withMultiplier:multiplier
                              withConstant:0.0f
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute, with the alignment being
/// modified by @a mutliplier and @a constant. The constraint is assigned
/// priority @e UILayoutPriorityRequired and is added to @a constraintHolder.
/// Returns the constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute, but first multiplied by @a multiplier and then with @a constant
/// added. For instance, if @a attribute is NSLayoutAttributeHeight, then the
/// height of @a firstView is set to be equal to
/// "multiplier * secondView.height + constant".
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                        withMultiplier:(CGFloat)multiplier
                          withConstant:(CGFloat)constant
                      constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                               onAttribute:attribute
                            withMultiplier:multiplier
                              withConstant:0.0f
                              withPriority:UILayoutPriorityRequired
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute, with the alignment being
/// modified by @a mutliplier and @a constant. The constraint is assigned the
/// priority @a priority and is added to @a constraintHolder. Returns the
/// constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute, but first multiplied by @a multiplier and then with @a constant
/// added. For instance, if @a attribute is NSLayoutAttributeHeight, then the
/// height of @a firstView is set to be equal to
/// "multiplier * secondView.height + constant".
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                        withMultiplier:(CGFloat)multiplier
                          withConstant:(CGFloat)constant
                          withPriority:(UILayoutPriority)priority
                      constraintHolder:(UIView*)constraintHolder
{
  NSLayoutConstraint* constraint = [NSLayoutConstraint constraintWithItem:firstView
                                                                attribute:attribute
                                                                relatedBy:NSLayoutRelationEqual
                                                                   toItem:secondView
                                                                attribute:attribute
                                                               multiplier:multiplier
                                                                 constant:constant];
  constraint.priority = priority;
  [constraintHolder addConstraint:constraint];
  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Creates Auto Layout constraints that align a view @a firstView
/// and @a secondView on the edge anchors specified by @a edges. The edge
/// anchors of @a firstView are aligned with the edge anchors in the safe area
/// layout guide of @a secondView. The constraints are added to the closest
/// common ancestor of the two views. Returns the constraints generated by this
/// method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
// -----------------------------------------------------------------------------
+ (NSArray*) alignFirstView:(UIView*)firstView
             withSecondView:(UIView*)secondView
            onSafeAreaEdges:(UIRectEdge)edges
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                                   onEdges:edges
                     edgesAreSafeAreaEdges:true];
}

// -----------------------------------------------------------------------------
/// @brief Creates Auto Layout constraints that align a view @a firstView
/// and @a secondView on the edge anchors specified by @a edges. The constraints
/// are added to the closest common ancestor of the two views. Returns the
/// constraints generated by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
// -----------------------------------------------------------------------------
+ (NSArray*) alignFirstView:(UIView*)firstView
             withSecondView:(UIView*)secondView
                    onEdges:(UIRectEdge)edges
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                                   onEdges:edges
                     edgesAreSafeAreaEdges:false];
}

// -----------------------------------------------------------------------------
/// @brief Creates Auto Layout constraints that align a view @a firstView
/// and @a secondView on the edge anchors specified by @a edges. If
/// @a edgesAreSafeAreaEdges is @e true the edge anchors of @a firstView are
/// aligned with the edge anchors in the safe area layout guide of
/// @a secondView. If @a edgesAreSafeAreaEdges is @e false the edge anchors of
/// @a firstView are aligned with the edge anchors of @a secondView itself.
/// The constraints are added to the closest common ancestor of the two views.
/// Returns the constraints generated by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
// -----------------------------------------------------------------------------
+ (NSArray*) alignFirstView:(UIView*)firstView
             withSecondView:(UIView*)secondView
                    onEdges:(UIRectEdge)edges
      edgesAreSafeAreaEdges:(bool)edgesAreSafeAreaEdges
{
  NSMutableArray* constraints = [NSMutableArray array];

  if (edges & UIRectEdgeLeft)
  {
    NSLayoutConstraint* constraint = [AutoLayoutUtility alignFirstView:firstView
                                                        withSecondView:secondView
                                                              onAnchor:NSLayoutAttributeLeft
                                                anchorIsSafeAreaAnchor:edgesAreSafeAreaEdges];
    [constraints addObject:constraint];
  }
  if (edges & UIRectEdgeRight)
  {
    NSLayoutConstraint* constraint = [AutoLayoutUtility alignFirstView:firstView
                                                        withSecondView:secondView
                                                              onAnchor:NSLayoutAttributeRight
                                                anchorIsSafeAreaAnchor:edgesAreSafeAreaEdges];
    [constraints addObject:constraint];
  }
  if (edges & UIRectEdgeTop)
  {
    NSLayoutConstraint* constraint = [AutoLayoutUtility alignFirstView:firstView
                                                        withSecondView:secondView
                                                              onAnchor:NSLayoutAttributeTop
                                                anchorIsSafeAreaAnchor:edgesAreSafeAreaEdges];
    [constraints addObject:constraint];
  }
  if (edges & UIRectEdgeBottom)
  {
    NSLayoutConstraint* constraint = [AutoLayoutUtility alignFirstView:firstView
                                                        withSecondView:secondView
                                                              onAnchor:NSLayoutAttributeBottom
                                                anchorIsSafeAreaAnchor:edgesAreSafeAreaEdges];
    [constraints addObject:constraint];
  }

  return constraints;
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns a view @a firstView
/// and @a secondView on the anchor specified by @a attribute. The anchor of
/// @a firstView is aligned with the anchor in the safe area layout guide of
/// @a secondView. The constraint is added to the closest common ancestor of
/// the two views. Returns the constraint generated by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
///
/// Not all values of enumeration NSLayoutAttribute can be used. Returns @e nil
/// if @a attribute has an unsupported NSLayoutAttribute value.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
           onSafeAreaLayoutGuideAnchor:(NSLayoutAttribute)attribute
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                                  onAnchor:attribute
                    anchorIsSafeAreaAnchor:true];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns a view @a firstView
/// and @a secondView on the anchor specified by @a attribute. The constraint
/// is added to the closest common ancestor of the two views. Returns the
/// constraint generated by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
///
/// Not all values of enumeration NSLayoutAttribute can be used. Returns @e nil
/// if @a attribute has an unsupported NSLayoutAttribute value.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                              onAnchor:(NSLayoutAttribute)attribute
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                                  onAnchor:attribute
                    anchorIsSafeAreaAnchor:false];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns a view @a firstView
/// and @a secondView on the anchor specified by @a attribute. If
/// @a anchorIsSafeAreaAnchor is @e true the anchor of @a firstView is aligned
/// with the anchor in the safe area layout guide of @a secondView. If
/// @a anchorIsSafeAreaAnchor is @e false the anchor of @a firstView is aligned
/// with the anchor of @a secondView itself. The constraint is added to the
/// closest common ancestor of the two views. Returns the constraint generated
/// by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
///
/// Not all values of enumeration NSLayoutAttribute can be used. Returns @e nil
/// if @a attribute has an unsupported NSLayoutAttribute value.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                              onAnchor:(NSLayoutAttribute)attribute
                anchorIsSafeAreaAnchor:(bool)anchorIsSafeAreaAnchor
{
  NSLayoutAnchor* firstViewAnchor;
  NSLayoutAnchor* secondViewAnchor;
  switch (attribute)
  {
    case NSLayoutAttributeLeft:
      firstViewAnchor = firstView.leftAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.leftAnchor
                          : secondView.leftAnchor);
      break;
    case NSLayoutAttributeRight:
      firstViewAnchor = firstView.rightAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.rightAnchor
                          : secondView.rightAnchor);
      break;
    case NSLayoutAttributeTop:
      firstViewAnchor = firstView.topAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.topAnchor
                          : secondView.topAnchor);
      break;
    case NSLayoutAttributeBottom:
      firstViewAnchor = firstView.bottomAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.bottomAnchor
                          : secondView.bottomAnchor);
      break;
    case NSLayoutAttributeLeading:
      firstViewAnchor = firstView.leadingAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.leadingAnchor
                          : secondView.leadingAnchor);
      break;
    case NSLayoutAttributeTrailing:
      firstViewAnchor = firstView.trailingAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.trailingAnchor
                          : secondView.trailingAnchor);
      break;
    case NSLayoutAttributeWidth:
      firstViewAnchor = firstView.widthAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.widthAnchor
                          : secondView.widthAnchor);
     break;
    case NSLayoutAttributeHeight:
      firstViewAnchor = firstView.heightAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.heightAnchor
                          : secondView.heightAnchor);
      break;
    case NSLayoutAttributeCenterX:
      firstViewAnchor = firstView.centerXAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.centerXAnchor
                          : secondView.centerXAnchor);
      break;
    case NSLayoutAttributeCenterY:
      firstViewAnchor = firstView.centerYAnchor;
      secondViewAnchor = (anchorIsSafeAreaAnchor
                          ? secondView.safeAreaLayoutGuide.centerYAnchor
                          : secondView.centerYAnchor);
      break;
    default:
      return nil;
  }

  NSLayoutConstraint* constraint = [firstViewAnchor constraintEqualToAnchor:secondViewAnchor constant:0];
  constraint.active = YES;

  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a constraintHolder that causes
/// @a view to have the same width and height. If @a widthDependsOnHeight is
/// true the width auto layout attribute depends on the height auto layout
/// attribute, if @a widthDependsOnHeight is false the dependency relationship
/// is reversed. Returns the constraint generated by this method.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) makeSquare:(UIView*)view
              widthDependsOnHeight:(bool)widthDependsOnHeight
                  constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility setAspectRatio:1.0
                             widthToHeight:widthDependsOnHeight
                                    ofView:view
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a constraintHolder that causes
/// @a view to have the aspect ratio specified by @a multiplier. If
/// @a widthToHeight is true the aspect ratio is width-to-height, if
/// @a widthToHeight is false the aspect ratio is height-to-width. Returns the
/// constraint generated by this method.
///
/// For a width-to-height aspect ratio, calculate the multiplier by dividing the
/// width by the height portion of the desired aspect ratio. For instance, if
/// the desired aspect ratio is 16:9, supply the result of 16 divided by 9 as
/// the value for @a multiplier.
///
/// For a width-to-height aspect ratio, if @a multiplier is greater than 1.0f
/// then @a view will be wider than high. If @a multiplier is less than 1.0f
/// then @a view will be higher than wide.
///
/// For a height-to-width aspect ratio, all of the above must be reversed.
///
/// If @a multiplier is 1.0f then @a view will be square, regardless of whether
/// @a widthToHeight is true or false.
///
/// @note The value of @a widthToHeight has a double meaning: In terms of Auto
/// Layout constraints, the value also describes the dependency relationship
/// between the width and the height layout attribute. For a width-to-height
/// aspect ratio (i.e. @a widthToHeight is true) the width attribute depends on
/// the height attribute. For a height-to-width aspect ratio, the height
/// attribute depends on the width attribute. If the Auto Layout subsystem is
/// unable to resolve dependencies, a potential solution might be to reverse the
/// dependency relationship (this might help even if you want @a view to be
/// square and @a widthToHeight has no actual meaning for the aspect ratio).
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) setAspectRatio:(CGFloat)multiplier
                         widthToHeight:(bool)widthToHeight
                                ofView:(UIView*)view
                      constraintHolder:(UIView*)constraintHolder
{
  NSLayoutAttribute dependingAttribute;
  NSLayoutAttribute dependentAttribute;
  if (widthToHeight)
  {
    dependingAttribute = NSLayoutAttributeWidth;
    dependentAttribute = NSLayoutAttributeHeight;
  }
  else
  {
    dependingAttribute = NSLayoutAttributeHeight;
    dependentAttribute = NSLayoutAttributeWidth;
  }
  NSLayoutConstraint* constraint = [NSLayoutConstraint constraintWithItem:view
                                                                attribute:dependingAttribute
                                                                relatedBy:NSLayoutRelationEqual
                                                                   toItem:view
                                                                attribute:dependentAttribute
                                                               multiplier:multiplier
                                                                 constant:0.0f];
  [constraintHolder addConstraint:constraint];
  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a constraintHolder that prevents
/// @a view to ever have its @a attribute become less than @a constant. The
/// constraint is assigned priority @e UILayoutPriorityRequired. Returns the
/// constraint generated by this method.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) setMinimumConstraint:(UIView*)view
                                   attribute:(NSLayoutAttribute)attribute
                                withConstant:(CGFloat)constant
                            constraintHolder:(UIView*)constraintHolder
{
  NSLayoutConstraint* constraint = [NSLayoutConstraint constraintWithItem:view
                                                                attribute:attribute
                                                                relatedBy:NSLayoutRelationGreaterThanOrEqual
                                                                   toItem:nil
                                                                attribute:NSLayoutAttributeNotAnAttribute
                                                               multiplier:1.0f
                                                                 constant:constant];
  [constraintHolder addConstraint:constraint];
  constraint.priority = UILayoutPriorityRequired;
  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a constraintHolder that prevents
/// @a view to ever have its @a attribute become greater than @a constant. The
/// constraint is assigned priority @e UILayoutPriorityRequired. Returns the
/// constraint generated by this method.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) setMaximumConstraint:(UIView*)view
                                   attribute:(NSLayoutAttribute)attribute
                                withConstant:(CGFloat)constant
                            constraintHolder:(UIView*)constraintHolder
{
  NSLayoutConstraint* constraint = [NSLayoutConstraint constraintWithItem:view
                                                                attribute:attribute
                                                                relatedBy:NSLayoutRelationLessThanOrEqual
                                                                   toItem:nil
                                                                attribute:NSLayoutAttributeNotAnAttribute
                                                               multiplier:1.0f
                                                                 constant:constant];
  [constraintHolder addConstraint:constraint];
  constraint.priority = UILayoutPriorityRequired;
  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a view for each visual format string
/// found in @a visualFormats. The views referred to by the visual format
/// strings must be present in @a viewsDictionary. Returns an array with all
/// constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) installVisualFormats:(NSArray*)visualFormats
                        withViews:(NSDictionary*)viewsDictionary
                           inView:(UIView*)view
{
  NSArray* constraints = [AutoLayoutUtility createConstraintsWithVisualFormats:visualFormats
                                                                         views:viewsDictionary];
  [view addConstraints:constraints];
  return constraints;
}

// -----------------------------------------------------------------------------
/// @brief Creates Auto Layout constraints, without activating/installing them,
/// for each visual format string found in @a visualFormats. The views referred
/// to by the visual format strings must be present in @a viewsDictionary.
/// Returns an array with all constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) createConstraintsWithVisualFormats:(NSArray*)visualFormats
                                          views:(NSDictionary*)viewsDictionary
{
  NSMutableArray* generatedConstraints = [NSMutableArray array];
  for (NSString* visualFormat in visualFormats)
  {
    NSArray* constraints = [NSLayoutConstraint constraintsWithVisualFormat:visualFormat
                                                                   options:0
                                                                   metrics:nil
                                                                     views:viewsDictionary];
    [generatedConstraints addObjectsFromArray:constraints];
  }
  return generatedConstraints;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default horizontal
/// spacing between sibling views. Example visual format string:
/// @"H:[view]-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) horizontalSpacingSiblings
{
  static CGFloat horizontalSpacingSiblings = -1.0f;
  if (horizontalSpacingSiblings < 0.0f)
    horizontalSpacingSiblings = [AutoLayoutUtility spacingForVisualFormatConstraint:@"H:[view]-[view]"];
  return horizontalSpacingSiblings;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default vertical spacing
/// between sibling views. Example visual format string: @"V:[view]-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) verticalSpacingSiblings
{
  static CGFloat verticalSpacingSiblings = -1.0f;
  if (verticalSpacingSiblings < 0.0f)
    verticalSpacingSiblings = [AutoLayoutUtility spacingForVisualFormatConstraint:@"V:[view]-[view]"];
  return verticalSpacingSiblings;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default horizontal
/// spacing between a view and its superview. Example visual format string:
/// @"H:|-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) horizontalSpacingSuperview
{
  static CGFloat horizontalSpacingSuperview = -1.0f;
  if (horizontalSpacingSuperview < 0.0f)
    horizontalSpacingSuperview = [AutoLayoutUtility spacingForVisualFormatConstraint:@"H:|-[view]"];
  return horizontalSpacingSuperview;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default vertical spacing
/// between a view and its superview. Example visual format string:
/// @"V:|-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) verticalSpacingSuperview
{
  static CGFloat verticalSpacingSuperview = -1.0f;
  if (verticalSpacingSuperview < 0.0f)
    verticalSpacingSuperview = [AutoLayoutUtility spacingForVisualFormatConstraint:@"V:|-[view]"];
  return verticalSpacingSuperview;
}

// -----------------------------------------------------------------------------
/// @brief Internal helper for the various horizontalSpacing* and
/// verticalSpacing* class methods.
///
/// @a visualFormat must describe a single relationship between two elements:
/// Either a view and its superview, or a view and a sibling view. The view
/// element(s) must always be named "view". Examples:
/// - View/superview relationship: "H:|-[view]"
/// - View/view relationship: "V:[view]-[view]"
///
/// The return value denotes the spacing between the two related elements.
// -----------------------------------------------------------------------------
+ (CGFloat) spacingForVisualFormatConstraint:(NSString*)visualFormat
{
  UIView* superview = [[[UIView alloc] initWithFrame:CGRectZero] autorelease];
  UIView* view = [[[UIView alloc] initWithFrame:CGRectZero] autorelease];
  [superview addSubview:view];
  view.translatesAutoresizingMaskIntoConstraints = NO;
  NSArray* constraints = [NSLayoutConstraint constraintsWithVisualFormat:visualFormat
                                                                 options:0
                                                                 metrics:nil
                                                                   views:NSDictionaryOfVariableBindings(view)];
  NSLayoutConstraint* constraint = constraints[0];
  return constraint.constant;
}

// -----------------------------------------------------------------------------
/// @brief Returns the spacing to use when placing elements inside a table view
/// cell content view; the spacing is the distance from the left or right edge
/// of the table view cell content view.
// -----------------------------------------------------------------------------
+ (CGFloat) horizontalSpacingTableViewCell
{
  static CGFloat horizontalSpacingTableViewCell = -1.0f;
  if (horizontalSpacingTableViewCell < 0.0f)
  {
    if ([LayoutManager sharedManager].uiType != UITypePhone)
    {
      UITableViewCell* cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"dummy"] autorelease];
      cell.textLabel.text = @"A";
      [cell layoutIfNeeded];
      horizontalSpacingTableViewCell = cell.textLabel.frame.origin.x;
    }
    else
    {
      // On the iPhone 6+ the above method to calculate the real value does not
      // work: The calculated value is 15, i.e. the same as on all other
      // devices, but when we look at the *REAL* spacing we see that on
      // iPhone 6+ it has increased to 20. Although hard-coding values is ugly,
      // we don't have any other choice :-( By basing our decision on the UIType
      // we hope to make this solution slightly more resilient: UITypePhone
      // hopefully covers other, future devices with wide screens, and these
      // hopefully behave the same as the iPhone 6+ and also use a larger
      // spacing.
      horizontalSpacingTableViewCell = 20;
    }
  }
  return horizontalSpacingTableViewCell;
}

// -----------------------------------------------------------------------------
/// @brief Returns the spacing to use when placing elements inside a table view
/// cell content view; the spacing is the distance from the top or bottom edge
/// of the table view cell content view.
// -----------------------------------------------------------------------------
+ (CGFloat) verticalSpacingTableViewCell
{
  // TODO Don't fake this, calculate the real value. Unfortunately we can't use
  // the same approach as in horizontalSpacingTableViewCell - with that approach
  // we would determine the distance of the text label from the top edge of the
  // content view, i.e. cell.textLabel.frame.origin.y. Unfortunately the value
  // of this is always 0 (zero). So instead we fake the real thing by returning
  // an approximate value.
  return [AutoLayoutUtility verticalSpacingSiblings];
}

@end
