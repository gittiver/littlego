Purpose of this document
------------------------
This document describes the research I did for this project, both at the start
and while coding.


Go Engines
----------
List of Go-playing programs: https://senseis.xmp.net/?GoPlayingPrograms

Aya
- http://www32.ocn.ne.jp/~yss/ (URL defunct)
- The program is labelled as "free software"
- The most recent version from 2008 is made available for download without
  source and for the Windows platform only
- Maybe the author could be persuaded to let me port the program to
  Mac OS X / iOS under a closed-source agreement?

NeuroGo
- http://webdocs.cs.ualberta.ca/~emarkus/neurogo/ (URL defunct)
- No source code, not even a downloadable binary

Fuego
- http://fuego.sourceforge.net/
- A library/framework for programming Go games, including a Go engine
- Released under LGPL v3, which unfortunately includes the redistribution
  clause(s) from the GPL v3
- This looks so promising that I might write to the developers (fuego-devel)
  with an inquiry as to whether they think I could include the library

SmartGo
- https://www.smartgo.com/
- Commercial product
- Already offers the iPhone applications "SmartGo" and "SmartGo Pro"; both apps
  cost money

Steenvreter, Magog and Migos
- http://erikvanderwerf.tengen.nl/
- These programs apparently solve go problems, they are not go playing engines
- I'm not sure if the source code of these programs is available

Explorer
- https://webdocs.cs.ualberta.ca/~mmueller/cgo/explorer.html
- Program is freeware
- Googling for "Explorer.sit.hqx" leads to the following download location
  ftp://ftp.icsi.berkeley.edu/pub/theory/mmueller/Explorer.sit.hqx
- The archive expands to a binary and a "Read me" file that explains that this
  is shareware
- The source code effectively is not available

Indigo
- http://www.mi.parisdescartes.fr/~bouzy/INDIGO.html
- Linux binary that understands GTP

Dave Dyer's Go Program
- http://www.andromeda.com/people/ddyer/go-program.html (URL defunct)
- Doesn't play

Pachi
- https://github.com/pasky/pachi
- Player program and framework
- Licensed under GPLv2

Moyoman
- http://www.moyoman.org/
- Player program written in Java
- Not very far developed, and also not actively developed anymore (last release
  is 2004)
- Licensed under the Apache License 2.0


Licensing
---------
GPL licensed software cannot be used for iOS applications under the current
terms of services of the iTunes Store and the App Store. Period. There are two
articles on fsf.org that describe a case where GNU Go was distributed over the
App Store. The second article explains where the GPL conflicts with Apple's
terms of services.
- https://www.fsf.org/news/2010-05-app-store-compliance/
- https://www.fsf.org/news/blogs/licensing/more-about-the-app-store-gpl-enforcement

Another interesting article explains that it's ok from a legal point of view to
distribute GPL'ed software via the App Store if you have the copyright on the
software (i.e. you wrote the software yourself)
- https://bonsansnom.wordpress.com/2011/01/08/about-apple-store-gpls-vlc-and-betrains/

An article written by someone who believes that it's ok to use GPL'ed software:
- http://www.geoffeg.org/wordpress/2009/10/07/the-iphone-and-the-gpl-v2-are-not-incompatible/
  (URL defunct)

An older discussion on the subject. There are many opinions and no conclusions,
though.
- http://diveintomark.org/archives/2008/03/07/iphone-gpl (URL defunct)
- One of the more interesting opinions is one that tries to refute the "spirit
  of the license" argument (where it is argued that it is difficult or expensive
  for an app user to customize an app with a modified version of the software)
- The reasoning is this: "So if I write a piece of code that only compiles if
  you use a $2000 compiler suite [...] then it is the code itself not the tools
  I am obligated to supply. If anyone can buy a $99 developer license that is
  just part of the tool chain cost."

The actual licenses:
- http://www.gnu.org/licenses/gpl-2.0.txt
- http://www.gnu.org/licenses/gpl-3.0.txt
- http://www.gnu.org/copyleft/lesser.html

Articles about the LGPL and iPhone apps:
- This one believes it's possible, although it's not in the spirit of the
  license
  http://huyzing.com/2009/08/24/compatibility-between-the-iphone-app-store-and-the-lgpl/
  (URL defunct)
- This one believes it's not possible because of the $99/year cost
  https://loufranco.com/blog/lgpl-and-the-iphone


Programming my own Go engine
----------------------------
Fuego is a so-called "Monte Carlo" engine, so that's what I am going to
research.
- A basic description what it's about: https://senseis.xmp.net/?MonteCarlo
- MCTS = Monte Carlo Tree Search
- "The principles of MCTS algorithms were published in the proceedings of the
  Computer and Games conference, which was held together with the Olympiad."
  (the ICGA Computer Olympiad, https://senseis.xmp.net/?ComputerOlympiad)
- UCT is a simple but effective form of MCTS, following link includes
  pseudo-code: https://senseis.xmp.net/?UCT
- RAVE seems to be another method of MCTS, but one that is a heuristic
  (refers to experience-based techniques for problem solving, learning, and
  discovery. Heuristic methods are used to speed up the process of finding a
  good enough solution, where an exhaustive search is impractical)
- MCTS publications: https://webdocs.cs.ualberta.ca/~mmueller/mcts.html
- Computer Go page: https://senseis.xmp.net/?ComputerGo

Research stopped for the moment because I haved decided to use Fuego.


GTP - Go Text Protocol
----------------------
The reference is here: https://www.lysator.liu.se/~gunnar/gtp/

Apparently there are two versions of GTP:
- GTP version 1: Although superseded by GTP version 2, this protocol version
  may still have some relevance because it is implemented by the ubiquitous
  GNU Go. Version 3.0.0 of GNU Go actually has the reference implementation of
  GTP version 1, which at the same time serves as the protocol specification
  since there is no other good documentation.
- GTP version 2: The current protocol version. The specification still has
  "draft" status, but since there have been no changes since 2002, it's pretty
  safe to assume that version 2 of the protocol is stable. In theory, GNU Go
  3.4 has the reference implementation of GTP version 2. Whether this is true
  in practice has still to be verified.

A simple GTP session might consist of the following commands:

  protocol_version
  name
  version
  boardsize 9
  clear_board
  showboard
  quit

With Fuego, this looks like this:

  protocol_version
  = 2

  name
  = Fuego

  version
  = 1.0

  boardsize 9
  =

  clear_board
  =

  showboard
  =
    A B C D E F G H J
  9 . . . . . . . . . 9
  8 . . . . . . . . . 8
  7 . . + . . . + . . 7
  6 . . . . . . . . . 6
  5 . . . . . . . . . 5
  4 . . . . . . . . . 4
  3 . . + . . . + . . 3
  2 . . . . . . . . . 2
  1 . . . . . . . . . 1  B to play
    A B C D E F G H J

  quit
  =

Fuego installs two executables:
- fuego (FuegoMain application): This is the GTP interface to GoUctPlayer, a
  Monte-Carlo tree search Go player.
- fuego_test (FuegoTest application): GTP interface to a GTP engine with test
  commands. The --player argument tells the application to use a player with
  the specified behaviour.

Attaching to a GTP interface involves the following steps:
- Launch the desired executable in the background
- Attach to the process' input and output streams
- Write to the input stream to give commands to the GTP engine
- Read from the input stream to get the GTP engine's answers
- Unfortunately, on iOS it is not possible to spawn a process in the background
  as it used to be possible with NSTask on Mac OS X
- For this reason, it is not possible to include the Fuego executable with the
  application, launch the program in the background and attach to its standard
  input and output streams
- Instead, I assume that all this needs to be "simulated" by spawning a thread


Fuego
-----
This section contains basic research about what services Fuego can provide.

A list of all GTP commands known by Fuego 1.0 (obtained with GTP command
"list_commands") follows. Those commands marked with an asterisk are described
in the GTP 2.0 specification.

all_move_values
autobook_additive_cover
autobook_close
autobook_counts
autobook_cover
autobook_expand
autobook_export
autobook_import
autobook_load_disabled_lines
autobook_mainline
autobook_merge
autobook_open
autobook_param
autobook_priority
autobook_refresh
autobook_save
autobook_scores
autobook_state_info
autobook_truncate_by_depth
boardsize (*)
book_add
book_clear
book_delete
book_info
book_load
book_moves
book_position
book_save
book_save_as
clear_board (*)
cputime
cputime_reset
echo
echo_err
final_score (*)
final_status_list (*)
fixed_handicap (*)
fuego-license
genmove (*)
get_komi
get_random_seed
gg-undo
go_board
go_clock
go_param
go_param_rules
go_param_timecontrol
go_player_board
go_point_info
go_point_numbers
go_rules
go_safe
go_safe_dame_static
go_safe_gfx
go_safe_winner
go_sentinel_file
go_set_info
gogui-analyze_commands
gogui-interrupt
gogui-play_sequence
gogui-setup
gogui-setup_player
is_legal
kgs-genmove_cleanup
kgs-time_settings
known_command (*)
komi (*)
list_commands (*)
list_stones
loadsgf (*)
name (*)
pid
place_free_handicap (*)
play (*)
protocol_version (*)
quiet
quit (*)
reg_genmove (*)
reg_genmove_toplay
savesgf
set_free_handicap (*)
set_random_seed
sg_compare_float
sg_compare_int
sg_debugger
sg_exec
sg_param
showboard (*)
time_lastmove
time_left (*)
time_settings (*)
uct_bounds
uct_default_policy
uct_estimator_stat
uct_gfx
uct_max_memory
uct_moves
uct_param_globalsearch
uct_param_player
uct_param_policy
uct_param_rootfilter
uct_param_search
uct_patterns
uct_policy_moves
uct_prior_knowledge
uct_rave_values
uct_root_filter
uct_savegames
uct_savetree
uct_score
uct_sequence
uct_stat_player
uct_stat_player_clear
uct_stat_policy
uct_stat_policy_clear
uct_stat_search
uct_stat_territory
uct_value
uct_value_black
undo (*)
version (*)

Working with .sgf files:
- The GTP commands "loadsgf" and "savesgf" are useful for this. The argument
  these commands take is a path to the .sgf file to save or load. Due to the
  limitations of the GTP protocol, the filename cannot include spaces, hash
  signs (#), or control characters.
- If coding is involved, the classes SgGameReader and SgGameWriter in the
  SmartGo library will be useful
- Fuego's implementation of the "loadsgf" GTP command takes an non-standard
  optional second argument. The argument must be a numeric value between 1 and
  "number of moves in .sgf + 1". The argument is intended to load a specific
  board position which corresponds to "the board position before the specified
  move". The implementation is flawed in that the SGF nodes behind the desired
  board position remain loaded in memory, which causes "list_moves", for
  instance, to list moves even if they are behind the desired board position.

Determine if stones are captured as the result of a move, and which stones:
- The GTP command "list_stones" enumerates the positions that the specified
  player has stones on. If compared with the current board situation in
  Little Go, any differences indicate which stones have been captured.
- Although the GTP specification does not recommend it, the result of GTP
  command "showboard" could also be used to find any differences with the
  current board situation in Little Go.
- Implementing this myself should also be not too hard: Code an algorithm that
  finds finds out how many liberties a stone or a group has, then examine the
  four neighbours of the stone that was just placed.

Scoring
- Possibly useful GTP commands: final_score (GoUctCommands::CmdFinalScore),
  final_status_list (GoUctCommands::CmdFinalStatusList),
  uct_score (GoUctCommands::CmdScore)
- The main class in GoGui is CountScore (net.sf.gogui.go.CountScore.java)
  - m_score = Array with board x/y coordinates as indices; each array element
    has a GoColor Wert (BLACK/WHITE/EMPTY)
  - m_dead = Marker of size X (= board size, e.g. 19)
    - Marker is a one-dimensional array with boolean values
    - Each point on the board has a constant index value which is used to access
      the array element that corresponds to the point
    - The Marker array size is constant, the size is chosen so that even with
      the maximum board size each point always references a valid array element
      (maximum board size is 25, array size is 25x25 = 625)
  - compute() re-calculates the score after each change made by the user
  - The result of compute() is placed into m_score

Two computer players:
- The "genmove" GTP command has an argument that allows to specify the color
  to generate a move for
- This can be leveraged to effectively let Fuego play against itself

Recommend a move
- The "reg_genmove" GTP command generates a move, but does not play it

Handicap
- The GTP standard has three GTP commands that can be used to setup handicap
  stones. Fuego implements these commands, but no other non-standard command
  related to handicap.
  - fixed_handicap
  - place_free_handicap
  - set_free_handicap
- According to the GTP standard, all commands can be used only as long as the
  board is empty.
  - Fuego faithfully implements the GTP standard, which means it does not allow
    the commands once setup stones have been placed or at least one move has
    been played that places a stone.
  - Fuego allows the commands after a pass move has been played.
- fixed_handicap <n>
  - This command places handicap stones on the board in fixed locations defined
    by the GTP standard [1]. The locations depend on the board size.
  - The command parameter is numeric and determines how many stones should be
    placed. Allowed values are 2-9.
  - The response to the command lists the vertices on which the GTP engine
    placed the handicap stones.
- place_free_handicap <n>
  - This command places handicap stones on the board in locations preferred by
    the GTP engine [2]. The GTP engine may place less stones than the requested
    number if the requested number is very high.
  - The command parameter is numeric and determines how many stones should be
    placed. The minimum number is 2. The maximum number is one less than the
    number of vertices on the board.
  - The response to the command lists the vertices on which the GTP engine
    placed the handicap stones.
  - Fuego uses the same locations that the GTP standard defines for the
    "fixed_handicap" command. If more stones are requested, Fuego lets the black
    player play stones using the "gen_move" command until either the requested
    number of stones is reached, or a pass move is played.
- set_free_handicap <vertices>
  - This command places handicap stones on the board in locations specified by
    the command.
  - The command parameter is a list of vertices that indicate how many stones
    and where they should be placed. The minimum number of vertices is 2. The
    maximum number of vertices is one less than the number of vertices on the
    board.
- Regardless of which command is used: Fuego places the stones on the board,
  creates corresponding SGF properties, and stores the number of handicap stones
  in GoRules. Once placed on the board, Fuego does not keep a memory of why a
  handicap stone was placed, i.e. the stone is treated as just another black
  stone that takes part in the board position evaluation as usual. Also, code
  analysis indicates that Fuego does not use the number of handicap stones in
  GoRules any way to evaluate the board position.
- [1] https://www.lysator.liu.se/~gunnar/gtp/gtp2-spec-draft2/gtp2-spec.html#sec:fixed-handicap-placement
- [2] https://www.lysator.liu.se/~gunnar/gtp/gtp2-spec-draft2/gtp2-spec.html#sec:free-handicap-placement

Setup a position
- The "gogui-setup" GTP command can be used to setup a position on the board
  without making play moves. For instance, an .sgf file saved after
  "gogui-setup" will not contain moves, just the board setup). This command
  exists because GTP v2 does not define such a command. The format is
  "gogui-setup <color> <vertex> [...]". The colors do not need to alternate.
  The color must be "B" or "W", i.e. it is not possible to clear an
  intersection. Fuego allows the command only if no moves have been played yet.
  Multiple "gogui-setup" commands can be submitted, each of which modifies the
  board according to the command arguments. The command can be used to replace
  handicap stones with setup stones.
- The "gogui-setup_player" command is used to define the color that should play
  first after a setup has been made. This command is submitted immediately
  after gogui-setup. The format is "gogui-setup_player <color>".
- The "gogui-play_sequence" GTP command uses the same format as "gogui-setup",
  but makes actual play moves. The player that should play first after the
  setup has been made is determined automatically (but can be changed using
  "gogui-setup_player").

Territory statistics
- The "uct_stat_territory" GTP command displays territory statistics
- For a detailed explanation of how to enable this, see
  https://sourceforge.net/p/fuego/wiki/ShowingTerritoryStatistics/
- Apparently the result of this command is a percentage for each vertex, based
  on which the sizes of the squares in the screenshot on the above page are
  drawn
- For scoring one could also define a threshold percentage above which a vertex
  is counted as territory for a color

Interrupting long-running GTP commands
- A long-running GTP command such as "genmove" can be interrupted by sending
  the special string "# interrupt". Apparently this has been implemented in
  Fuego to accomodate the GoGui client. See chapter 10 in the GoGui manual for
  some details (http://gogui.sourceforge.net/doc/interrupt.html, URL defunct]
- Fuego also understands the GTP command "gogui-interrupt". The comments in
  Fuego's source code explain that this command does not actually do anything,
  its presence in the output of "list_commands" (another GTP command) merely
  indicates that this version of Fuego is capable of handling the string
  "# interrupt"
- Manual experimenting with the Fuego 1.1 engine reveals how "# interrupt" is
  handled
  - The string "# interrupt" is not a GTP command because it has no return
    value
  - Sending an interrupt causes the GTP engine to stop processing the current
    command. The GTP engine then prints the result of the interrupted command
    to the protocol stream.
  - Sending an interrupt if the engine is idle (i.e. not processing a command)
    simply does nothing
  - Sending an interrupt has no effect if anything else is already in the
    GTP engine's input buffer. This is best explained with an example:
    1) Submit "genmove W"
    2) Submit "genmove B"
    3) Send "# interrupt"
    Since "genmove B" is already in the engine's input buffer, the interrupt
    has no effect on "genmove W". After "genmove W" has been fully processed,
    the GTP engine will then start processing "genmove B". Again, the interrupt
    has no effect on "genmove B".
- Notes on interrupting a "genmove" command
  - The engine reports success for the command and actually generates a move
  - The question is: Which move is generated? Is it the best move so far, or
    just the last move that the search algorithm has been evaluating when it
    detected interruption?
  - Answer: From looking at the implementation of SgUctSearch::SearchOnePly() in
    SgUctSearch.cpp, it would appear that the best move so far is selected.

Ko rules
- The GTP command "go_param_rules ko_rule" can be used to set one of three
  different ko rules
  - simple: The simple ko rule where only repetition of the position two moves
    ago is forbidden.
  - pos_superko: Positional superko
  - superko: Situational superko (the source code documentation has the
    information that this is indeed situational superko)
- The default is positional superko
- Resources that explain what a superko is, and what the difference is between
  situational and positional superko
  - https://senseis.xmp.net/?Superko
  - https://en.wikipedia.org/wiki/Rules_of_Go#Repetition

Other useful stuff
- The "go_point_info" GTP command allows to query Fuego about various properties
  of the specified point. One of the properties is whether the point would be a
  legal move for either black or white
- The "is_legal" GTP command allows to query Fuego whether it would be legal for
  the specified player to play on the specified point


Details on Fuego's smartgame module
-----------------------------------
Classes
- SgNode represents a node in a tree structure
- SgProp represents a property of a node
- SgPoint represents a vertex on the board, but can also be used to refer to
  the "virtual" point of a pass move

Nodes and properties
- One node can have 0-n properties
- A property has a type (e.g. SG_PROP_MOVE)
  - The term that is used, though, is "ID" - a misnomer in my opinion.
  - SgPropID is the type used to store a property ID/type
  - SgProp::ID() is called to get at a property object's ID/type
- A property is additionally classified by (binary) flags that can be set or
  cleared on it
  - For instance, a property with ID SG_PROP_MOVE has set the flag
    SG_PROPCLASS_MOVE, and either SG_PROPCLASS_BLACK or SG_PROPCLASS_WHITE
    to indicate whether the move was made by the black or the white player
  - SgProp::Flag() returns a boolean value; the method is used to check whether
    a given flag is set on the property object

The node tree
- The terminology used by documentation and SgNode methods views the tree with
  the root node at the top, and the branches pointing downwards
- For instance
                                node0
                               /    \
                              /      \
                           node1     node2
                          /  |  \        \
                         /   |   \        \
                      node3 node4 node5   node6

- Looking at this example, and at the methods in SgNode, one can say that
  - node0->IsRoot() == true
  - node1->Father() == node0
  - node1->RightBrother() == node2
  - node1->LeftBrother() == NULL
  - node6->HasBrother() == false
  - node5->NumLeftBrothers() == 2
  - node1->NumSons() == 3
  - node1->LeftMostSon() == node3
  - node1->RightMostSon() == node5
  - SgNode::IsTerminal() == true for node3, node4, node5 and node6
  - SgNode::IsBranchPoint() == true for node0 and node1
  - SgNode::IsOnMain() == true for node0, node1 and node3

Code snippets:

void inspectProp(SgProp* prop)
{
  SgPropID propID = prop->ID();
  std::string propLabel = prop->Label();
  bool black = prop->Flag(SG_PROPCLASS_BLACK);
  bool white = prop->Flag(SG_PROPCLASS_WHITE);
  bool info = prop->Flag(SG_PROPCLASS_INFO);
  bool anno = prop->Flag(SG_PROPCLASS_ANNO);
  bool stat = prop->Flag(SG_PROPCLASS_STAT);
  bool move = prop->Flag(SG_PROPCLASS_MOVE);
  bool mark = prop->Flag(SG_PROPCLASS_MARK);
  NSLog(@"propID = %d, propLabel = %s, black = %d, white = %d, info = %d, anno = %d, stat = %d, move = %d, mark = %d",
        propID, propLabel.c_str(), black, white, info, anno, stat, move, mark);
}

void inspectNode(SgNode* node)
{
  bool hasFather = node->HasFather();
  bool isRoot = node->IsRoot();
  bool hasLeftFather = node->HasLeftBrother();
  bool hasRightBrother = node->HasRightBrother();
  bool hasSon = node->HasSon();
  bool hasBrother = node->HasBrother();
  bool isOnMain = node->IsOnMain();
  NSLog(@"hasFather = %d, isRoot = %d, hasLeftFather = %d, hasRightBrother = %d, hasSon = %d, hasBrother = %d, isOnMain = %d",
        hasFather, isRoot, hasLeftFather, hasRightBrother, hasSon, hasBrother, isOnMain);
  const SgPropList& propList = node->Props();
  SgPropListIterator propListIterator(propList);
  while (propListIterator)
  {
    SgProp* prop = *propListIterator;
    inspectProp(prop);
    ++propListIterator;
  }
}


Go topics
---------
Collection of computer Go algorithms:
- https://senseis.xmp.net/?ComputerGoAlgorithms

Scoring
- https://senseis.xmp.net/?Scoring
- https://senseis.xmp.net/?TerritoryAndAreaScoring
- https://senseis.xmp.net/?InternationalRules

Benson's Algorithm
- https://senseis.xmp.net/?BensonSAlgorithm
- https://senseis.xmp.net/?BensonsDefinitionOfUnconditionalLife%2FExamples
- Fuego's GTP command for this is "go_safe_gfx benson". The result simply lists
  all points for each color that are unconditionally alive. The client needs to
  find out itself which points are connected. The result of the GTP command
  looks like this:

= BLACK F1 G1 H1 J1 F2 G2 H2 J2 F3 G3 H3 B5 C5 D5 E5 A6 B6 C6 A7 B7 C7 D7 A8 B8 C8 A9 B9 C9
WHITE E8 F8 G8 H8 J8 E9 F9 G9 H9 J9
COLOR #980098 D8 D9
CIRCLE E7 D8 D9
TEXT Solver: benson  B: 28 (34 %)  W: 10 (12 %)  Both: 38 (46 %)  Regions: 7

  It is not clear what the CIRCLE and COLOR lines mean (probably is related to
  displaying graphics). If one color has no points, the result looks like this:

= BLACK F1 G1 H1 J1 F2 G2 H2 J2 F3 G3 H3 B5 C5 D5 E5 A6 B6 C6 A7 B7 C7 D7 A8 B8 C8 A9 B9 C9
WHITE
COLOR #980098 D8 D9
CIRCLE E7 D8 D9
TEXT Solver: benson  B: 28 (34 %)  W: 10 (12 %)  Both: 38 (46 %)  Regions: 7


Fuego playing strength
----------------------
Essential parameters for modifying Fuego's playing strenght are described here:
  https://sourceforge.net/apps/trac/fuego/wiki/FAQ1
  https://sourceforge.net/apps/trac/fuego/wiki/FAQ3

Summary
- With "Reuse subtree" enabled, Fuego does not discard results from a previous
  search. "Reuse subtree" by default is enabled. Enable "reuse subtree" with
  "uct_param_player reuse_subtree 1".
- Pondering allows Fuego to think during opponent's turn. Pondering requires
  "Reuse subtree" to be enabled. Pondering by default is disabled. Enable
  pondering with "uct_param_player ponder 1".
- Fuego will stop pondering after a certain time. By default this limit is set
  to 300 seconds. Set the pondering limit (in seconds) with
  "uct_param_player max_ponder_time 300".
- More memory allows Fuego to store more nodes and to keep more results around,
  making calculations more accurate. Instead of the amount of memory, it is also
  possible to change the number of nodes. Changing the amount of memory
  automatically adjusts the number of nodes, and vice versa. Set the available
  memory (in bytes) with "uct_max_memory 500000000". Set the number of nodes
  with "uct_param_search max_nodes 6000000".
- More search time gives Fuego a better chance to find good moves. By default
  the time limit for searching is set to 10 seconds. Set the time available for
  searching with "go_param timelimit 6.5". Remove the time limit entirely with
  "uct_param_player ignore_clock 1" (not advisable, this will send the search
  algorithm on a mission to fry your CPU). An active GTP client might also
  interrupt a search in progress (due to a "genmove" GTP command) by sending
  the string "# interrupt" to the GTP engine.
- More games gives Fuego a better chance to find good moves. By default there
  is no limit for this setting (or more accurate: the maximum allowable value
  for a double, which is 1.79769e+308 on a Mac). Change this setting with
  "uct_param_player max_games 123456".

Copy & paste templates:
- Start Fuego
  ~/Documents/dev/littlego/3rdparty/install/Developer/SDKs/MacOSX10.6.sdk/bin/fuego
- Observe Fuego's memory usage with "top". The following example refers to the
  Mac OS X 10.6 version of the "top" command.
  top -stats pid,command,rsize,vsize,rshrd,rprvt,vprvt -pid 54439
- GTP commands
  uct_param_player ponder 1
  uct_max_memory 500000000
  uct_param_player reuse_subtree 1
  loadsgf /Users/patrick/Documents/go-games/19x19/pw6-gokifu-20110915-Choi_Cheolhan-Kim_Kiyoung.sgf


Fuego resigning mechanics
-------------------------
- The resigning behaviour is modified by these two GTP commands:
  - uct_param_player resign_min_games <12345>
  - uct_param_player resign_threshold <12345>
- resign_min_games
  - From the source code docs: "Minimum number of simulations to check for
    resign."
  - This comment allows some interpretation, so additional source code is
    required
  - Result: The number of playouts must be greater than (>) resign_min_games
    for resignation to become possible
  - Consequence: If the "max_games" parameter falls below resign_min_games,
    resignation becomes impossible because the required number of playouts can
    never be reached
- resign_threshold
  - From the source code docs: "Threshold for position value to resign."
  - This comment allows some interpretation, so additional source code is
    required
  - Result: A search yields a "best move". The quality of the move is valued
    between 0 and 1. A higher value means that the move is better. The quality
    of the best move must be smaller than (<) resign_threshold for resignation
    to become possible.
- The computer resigns the game only if the conditions for both resign_min_games
  and resign_threshold are met
- Experiment: Setting resign_threshold to 1 causes Fuego to resign immediately
  once it no longer plays moves from the opening book
- Default values
  - The default value for resign_threshold is automatically adjusted when the
    board size changes:
    - Board size < 15 : The default value is 0.05
    - Board size >= 15 : The default value is 0.08
    The source comment for this is
      // Need higher resign threshold, because GoUctGlobalSearch uses
      // length modification on large board
  - At the time of writing, the default value for resign_min_games is always
    5000 (board size has no influence)
- resign_min_games, and possibly resign_threshold also, have an influence on
  the "early_pass" behaviour of the UCT player


Fuego territory statistics
--------------------------
Cf. https://sourceforge.net/p/fuego/wiki/ShowingTerritoryStatistics/
- First, switch on the collection of territory statistics in Fuego with the
  following GTP command:
  uct_param_globalsearch territory_statistics 1
- Data collection starts when the next search is made. This happens when
  - A move is made
  - Pondering is on and Fuego searches in the background
  - A search is triggered purely for the purpose of data collection, for
    instance with this GTP command:
    reg_genmove B
  No search is made when a move from the opening book is selected.
- Statistics can be obtained from Fuego with this GTP command:
    uct_stat_territory
- The command fails if no statistics are available. The command succeeds even if
  the statistics do not reflect the current board position. Two common examples
  where this happens is when one of the GTP commands "clear_board" or
  "gogui-play_sequence" is sent: The statistics in this case will reflect the
  board position before the board-changing GTP command was sent.
- The result of "uct_stat_territory" is a 2D matrix of decimal values. The
  matrix dimensions correspond to the dimensions of the Go board. Each matrix
  element (i.e. each decimal value) corresponds to an intersection on the board.
- A decimal value represents the percentage of playouts that ended up with
  the corresponding intersection being territory for one of the two colors:
  - A positive value means that the intersection ended up as black territory
    more frequently than it ended up as white territory
  - A negative value means that the intersection ended up as white territory
    more frequently than it ended up as black territory
- Decimal values range from -1.0 (always white) to +1.0 (always black)


Rules of Go
-----------
There are many rulesets to play Go, an overview is available at the Sensei's
Library '[1] and, even more concise, on the British Go Association website [2].
A ruleset is a compilation of rules that govern the following:
- What constitutes a legal move
  - Which ko rule is used?
  - Is suicide possible?
- How the score is calculated
  - Which is the default komi?
  - Which scoring system is in use?
  - Which counting method is in use?
  - Are points in seki counted?
  - Other things that influence the score, such as handing a pass stone to the
    opponent when passing, or requiring white to make the last move (both AGA
    rules specialities)
- Procedure
  - How is the starting (= black) player determined?
  - How are handicap points placed?
  - When does the game end?
  - At the end of the game, how are disputes about life and death resolved?

With some restrictions, Little Go allows the user to compose his own ruleset
when he starts a game, thus enabling the user to play according to most of the
common rulesets. Here is an overview:

                | Ko          | Suicide |      |           | Game ending
                | rule        | allowed | Komi | Scoring   | procedure
----------------+-------------+---------+------+-----------+-------------------------------------------------------------------------------------------
Japanese rules  | Simple      | No      | 6.5  | Territory | Two passes (play is resumed to settle disputes, non-alternating play)
Chinese rules   | Positional  | No      | 7.5  | Area      | Two passes (play is resumed to settle disputes, non-alternating play)
AGA rules       | Situational | No      | 7.5  | Area      | Two passes (play is resumed to settle disputes, alternating play), four passes (game ends)
IGS rules       | Simple      | No      | 6.5  | Territory | Three passes (play is resumed by discarding the last pass move to settle disputes)
Little Go rules | Simple      | No      | 7.5  | Area      | Two passes (play is resumed to settle disputes, alternating play)


Little Go does not strive to provide a 100% exact representation of the various
rulesets. The main goal of the app is, after all, to let the user play and enjoy
the game. Here are some notable exceptions:
- Little Go uses the handicap positions specified in section 4.1.1 of the GTP v2
  specification ([3]). Little Go does not allow free placing of handicap stones,
  and it only supports a maximum of 9 handicap stones.
- Little Go has its own counting methods, one for Territory scoring and one for
  Area scoring. Little Go's counting methods are, of course, based on the two
  most commonly used counting methods for the two scoring systems (Japanese and
  Chinese counting methods). See the following sections for more information.
- When compensating white for black handicap stones, Little Go follows the
  counting method of the Chinese rules and compensates white by adding n points
  to the score. The AGA rules area counting method, however, compensates white
  by adding n-1 points. So there is a difference of 1 point that someone who
  wants to play by AGA rules might find irritating or even wrong.


[1] https://senseis.xmp.net/?RulesOfGo
[2] https://www.britgo.org/rules/compare.html
[3] https://www.lysator.liu.se/~gunnar/gtp/gtp2-spec-draft2/gtp2-spec.html#sec:fixed-handicap-placement


Scoring and counting
--------------------
The terms "scoring" and "counting" are often used interchangeably (e.g.
"chinese scoring", "chinese counting") when in fact the two are different
things:
- The scoring system in use determines *what* counts. For instance, do captured
  stones count? Do occupied intersections count?
- The counting method in use determines *how* the count is made. For instance,
  with territory scoring you can either add captured stones to the score of the
  capturing player, or you can subtract captured stones from the score of the
  player who owns the stones.
- The scoring system has an influence on how the game is played and is part of
  the game rules.
- The scoring system determines which counting methods can be used.
- Using different counting methods may yield different individual scores for
  each player, but
  - The winning player always remains the same
  - Also, the amount by which a player wins always remains the same (e.g.
    "black wins by 3.5 points")

Little Go currently distinguishes between two scoring systems. The user must
select one of these when he starts a game:
- Territory Scoring
- Area scoring

Little Go currently does not allow the user to select a specific counting method
because it assumes that the user is mainly interested in the final score, which
expresses who won, and by how much that player won. Nevertheless, Little Go
shows details about how the final score was calculated. It can be said that
Little Go has its own counting method.

Finally, some clarification of terms:
- Chinese scoring = The scoring system used in the Chinese ruleset. The Chinese
  ruleset uses the Area scoring system, which is why Chinese scoring is often
  used interchangeably with Area scoring.
- Chinese counting = The counting system used in the Chinese ruleset. This
  counting system can be used to determine the score in a game that uses Area
  scoring, which is why Chinese counting is sometimes used interchangeably with
  Area scoring.
- Japanese scoring = The scoring system used in the Japanese ruleset. The
  Japanese ruleset uses the Territory scoring system, which is why Japanese
  scoring is often used interchangeably with Territory scoring.
- Japanese counting = The counting system used in the Japanese ruleset. This
  counting system can be used to determine the score in a game that uses
  Territory scoring, which is why Japanese counting is sometimes used
  interchangeably with Territory scoring.

Links & resources
- https://senseis.xmp.net/?Scoring
  - Has basic rules for the two scoring systems
- https://www.britgo.org/rules/compare.html
  - Very good comparison of different Go rulesets, including some clarification
    regarding the handling of handicap compensation in the various rulesets
  - Also has an enlightening "Scoring" section that explains how the AGA rules
    use Area scoring, while at the same time supporting both territory AND area
    counting methods.
- https://senseis.xmp.net/?TerritoryAndAreaScoring
  - Compares the two scoring systems
- https://senseis.xmp.net/?ChineseCounting
  - The counting method most often used for area scoring
- https://senseis.xmp.net/?JapaneseCounting
  - The counting method most often used for territory scoring
- https://senseis.xmp.net/?Komi
  - Explains which Komi should be used for the different scoring systems

GTP commands involved in scoring
- go_param_rules japanese_scoring
  - This is the main command that distinguishes between area scoring (parameter
    value = 0) and territory scoring (parameter value = 1)
- go_param_rules capture_dead
  - Somewhere in the Fuego source code the parameter is documented like this:
    "Whether it necessary to capture dead stones. With some rules all
    un-captured stones count as alive."
  - None of the rules (= scoring systems) that Little Go supports mandate that
    un-captured stones count as alive, therefore we must set the "capture_dead"
    parameter to 0 (= turned off)
  - 0 is already the default value, so no GTP command must be sent
- go_param_rules extra_handicap_komi
  - Somewhere in the Fuego source code the parameter is documented like this:
    "Each handicap stone counts as an extra komi point for white.
    This extra komi point is not included in the komi settings. Used by
    the KGS Go server. Default is false."
  - This command turns handicap compensation on (parameter value = 1) or off
    (parameter value = 0). Since Little Go's scoring implementation (GoScore.m)
    directly ties handicap compensation to the scoring system, the GTP command
    must be sent whenever the scoring system changes.
  - The "Counting methods" section below mentions several different handicap
    compensation counting methods. Fuego can only handle those counting methods
    for which the total compensation is equal to the number of handicap stones
    (n). For instance, Fuego cannot properly handle AGA rules with area
    counting, because for that counting method the total compensation is n-1.
- uct_param_player early_pass
  - The meaning of this parameter is not fully understood
  - According to this fuego-devel post [1], early_pass = 1 may be helpful when
    territory scoring is active
  - This Fuego wiki page [2] also mentions early_pass, however the main purpose
    of the parameter supposedly is "to annoy human opponents less with
    meaningless moves in the end game."
  - Since I can't see the exact meaning of the parameter in connection to the
    scoring system, I just stick to its intended meaning and leave it at its
    default value 1 (= turned on)

[1] https://sourceforge.net/mailarchive/message.php?msg_id=31365068
[2] https://sourceforge.net/apps/trac/fuego/attachment/wiki/JapaneseRules/%5Bfuego-devel%5D%20Supported%20Go%20rules.txt


Counting methods
----------------
This section has details about a number of common counting methods, in case
future implementation of the app want to provide the user with a choice.

Glossary
- Territory = Empty intersections surrounded by the stones of a color
- Area = Intersections occupied by the stones of a color

Territory scoring
- Japanese rules
  - Information taken from [1], [2], [3], [11]
  - Count territory
    - Exclude territory surrounded by stones in seki
  - Subtract from territory
    - Prisoners
    - Dead stones
    - Both of these are subtracted because according to the rules prisoners and
      dead stones are filled into the territory on the board, thus diminishing
      the territory count
    - Note: The official rules ([1]) do not mention what happens if there are
      more prisoners and dead stones than there is territory to fill in. One of
      the Sensei's Library pages ([3]) says that any surplus stones are added to
      the opponent's score.
  - Komi
    - Add komi to white's score
    - Note: I did not find this in [1], in fact the rules don't mention komi at
      all. The information how to score komi appears in [11]. Also, [2] mentions
      komi but does not say how to count it.
  - Handicap
    - Not relevant because area is not counted
- Little Go
  - Count territory
    - Exclude territory surrounded by stones in seki
  - Add prisoners
  - Add dead stones
  - Komi
    - Add komi to white's score
  - Handicap
    - Not relevant because area is not counted

Area scoring
- Chinese rules
  - Information taken from [4], [5], [6], [11]
  - Count territory
    - Include territory surrounded by stones in seki
  - Add number of stones
  - Add half of the neutral area to each player's score
  - Komi
    - Subtract 3.75 from black's score (for a 7.5 komi)
    - Note: The official rules [4] do not state anything about non-standard
      komi, but it's reasonable to assume that we should always subtract half of
      the komi from black's score
  - Handicap
    - If the handicap is n stones, and n>0, add n/2 to white's score and
      subtract n/2 from black's score
    - Note: I did not find this in the official rules [4]. The way how to score
      handicap compensation comes from [11]. One of the Sensei's Library pages
      [6] says to add n compensation to white's score, but another page [12]
      follows the convention on [11]
- AGA rules, territory counting (the default, as specified by the rules)
  - Information taken from [7], [8], [9], [10], [11]
  - Count territory
    - Include territory surrounded by stones in seki
  - Subtract from territory
    - Prisoners
      - Includes pass stones
      - Includes the pass stone for the very last pass made by white
    - Dead stones
    - Note: The rules [7] mention that "it is customary for the players to fill
      in their opponent's territory with their prisoners, and to then rearrange
      their territories to facilitate counting. These are merely mechanical
      conventions to simplify counting". Since Little Go is quite capable of
      counting without any simplifications, these conventions need not be
      followed by Little Go. On the other hand, not following conventions might
      result in negative scores. It would also mean that the AGA rules and the
      Japanese rules territory counting methods differ, which is probably not
      what the designers of the AGA rules intended. This example beautifully
      shows the futility of strictly adhering to the letters of a ruleset.
  - Komi
    - Add komi to white's score
- AGA rules, area counting
  - Information taken from [7], [8], [9], [10], [11]
  - Count territory
    - Include territory surrounded by stones in seki
  - Add number of stones
  - Komi
    - Add komi to white's score
  - Handicap
    - If the handicap is n stones, and n>0, add n-1 handicap compensation to
      white's score
- Little Go
  - Count territory
    - Include territory surrounded by stones in seki
  - Add number of stones
  - Komi
    - Add komi to white's score
  - Handicap
    - If the handicap is n stones, and n>0, add n handicap compensation to
      white's score


[1] https://www.cs.cmu.edu/~wjh/go/rules/Japanese.html
[2] https://senseis.xmp.net/?JapaneseRules
[3] https://senseis.xmp.net/?JapaneseCounting
[4] https://home.snafu.de/jasiek/c2002.pdf
[5] https://senseis.xmp.net/?ChineseRules
[6] https://senseis.xmp.net/?ChineseCounting
[7] https://www.usgo.org/files/pdf/completerules.pdf
[8] https://www.cs.cmu.edu/~wjh/go/rules/AGA.commentary.html
[9] https://senseis.xmp.net/?AGARules
[10] https://www.lifein19x19.com/forum/viewtopic.php?f=45&t=10634
[11] https://www.britgo.org/rules/compare.html
[12] https://senseis.xmp.net/?TerritoryAndAreaScoring


Settling life & death disputes
------------------------------
At the end of the game, before the score can be determined, players must agree
on which stones on the board are alive, and which are dead. If disputes arise,
they are settled according to the rules in use, which can cause different move
patterns to emerge.

End of game signal / beginning of the scoring phase:
- Japanese, Chinese and AGA rules: 2 consecutive pass moves
- IGS rules: 3 consecutive pass moves

Resuming play to settle disputes
- Japanese rules (from [1])
  - A player can request that the game be resumed
  - The opponent must oblige the request and has the right to play first
  - In other words: It is not relevant who made the second pass, the same
    player can play again.
- Chinese rules (from [2], buried in chapter 3 "Rules for Referees" in
  section 21 "Ending the game")
  - 21.3 and 21.4 seem to contradict, so I assume that 21.4 overrides 21.3
  - To quote 21.4: "Both players must agree about which stones are dead and
    which are alive. If there is disagreement, the game is resumed. The one who
    thinks the stones are dead plays first, and the argument is resolved by
    playing it out."
  - As with Japanese rules, it is not relevant who made the second pass, the
    same player can play again.
- AGA rules (from [3])
  - When play resumes, the sequence of play continues as normal from the last
    pass move, i.e. the first move is made by the opponent of the player who
    made the last pass move.
- IGS rules (from [4])
  - An undo of the third pass move is made, then play resumes
  - The sequence of play continues as normal from the last pass move, i.e. the
    first move is made by the opponent of the player who made the last pass
    move.
  - Note: This is my interpretation of the rules as outlined in [4]. The wording
    in that document is not unambiguous.

Special AGA rules (from [3], [5], [6] and, especially, [7])
- If the two pass moves signaling the end of the game are followed by another
  two consecutive pass moves (making for a total of 4 pass moves), the game ends
  immediately, with all stones on the board deemed alive.
- White must always make the last pass move. The result is that the number of
  pass moves at the end of the game can vary between 2-5


[1] https://www.cs.cmu.edu/~wjh/go/rules/Japanese.html
[2] https://home.snafu.de/jasiek/c2002.pdf
[3] https://www.usgo.org/files/pdf/completerules.pdf
[4] https://home.snafu.de/jasiek/igsrules.html
[5] https://www.cs.cmu.edu/~wjh/go/rules/AGA.commentary.html
[6] https://senseis.xmp.net/?AGARules
[7] https://www.lifein19x19.com/forum/viewtopic.php?f=45&t=10634


Redesigning the drawing mechanism in PlayView (v0.8)
----------------------------------------------------
During development of version 0.8 I decided to revise the implementation of how
the PlayView class is drawing the Go board. The rationale for this is that the
current implementation is extremely simple and brute force: Whenever an update
is required, the entire board is re-drawn from scratch. This brute force
approach has the potential to consume too much CPU power and thus to reduce
battery life. Since there already is some optimization in place that tries to
coalesce multiple update cycles into one (e.g. while loading a game), the main
area affected by constant redrawing is when the user wants to place a stone and
is panning around the board.

So the first thing I am planning to do is to measure with Instruments.app on a
real device how much CPU power is consumed during a panning session. This will
be the benchmark that the new implementation must improve.

Ideas for the new implementation
- Pre-calculate coordinates of points, lines, edges, etc. only once when the
  bounds of the view change (e.g. when it is drawn for the first time, or after
  an interface orientation change) or when the board size changes. Currently
  those coordinates are calculated from scratch each time the view is drawn.
- The new implementation must be smart: It must be capable of deciding which
  parts of the board need to be updated in reaction to a specific event. We
  will therefore need to revisit the various events that can affect how the
  board is drawn, and define for each event what parts of the board are
  affected, and how.
- Layers
  - Conceptually, the PlayView main drawing method drawRect:() already splits
    drawing tasks into separate layers (e.g. first draw the board, then draw the
    lines on top, then draw the star points on top, etc.). It is probably a good
    idea to create real layers using QuartzCore, instead of just doing layers in
    concept.
  - With layers, the smart new implementation will be able to conclude from a
    specific event which layers need to be changed, instead of redrawing all
    layers.
  - A simple version of the layering solution will still update an entire layer
    whenever that layer needs to be changed, even if the change affects only a
    small rectangle.
- Rectangles
  - The UIKit drawing concept sees the view as a simple 2-D plane, not as a set
    of stacked layers, and is based on updating rectangles within that plane.
  - To make use of this concept, the smart new implementation will be able to
    conclude from a specific event which partial rectangles need to be updated,
    instead of updating the entire view rectangle.
  - A simple version of the rectangle-based solution will update the partial
    rectangles in all layers, even if the change affects only one or two layers.
- The ultimate smart solution will be able to combine the two approaches: When
  an event occurs, it will determine 1) which layers, and 2) which rectangles
  are affected by the event, then it will update only those things that really
  need to be changed.

Things that should also be kept in mind:
- What about the optimization approach where one creates an image that can then
  be used as a canvas to draw on? Does it make sense to create such an image for
  those parts of the Go board that are relatively static (i.e. stuff that
  changes only with board size) and to combine the image with layers?
- Is it necessary to take into account that in the future the app might support
  zooming the Go board?


Benchmark results
- Set up the user defaults with a 19x19 board for new games, two human
  players, and the "human vs. human games" profile set not to use pondering (to
  eliminate all interference by Fuego)
- Kill all applications to eliminate other outside interference
- Start Instruments, then wait a moment until system activity dies down before
  starting to pan
- Note that during the entire test on all devices the system load is always 0%,
  only user load appears to be relevant
- The 5 sampling actions are
  - User load for the idle system (i.e. before beginning with the test) between x% and y%
  - Starting to pan lets the user load quickly rise to x-y%
  - When wildly panning, user load is constantly above a certain threshold x%, peaking at y%
  - When panning normally, user load is between x and y%
  - Placing the stone lets the user load go back down to the original x-y%

                                    Idle   Start     Wildly             Normal    Placing
                                    load   panning   panning            panning   stone
----------------------------------------------------------------------------------------
Original implementation (build from commit c2566ce86b5ccad0e3eb2f7c671fb2df5e0e3747)
  iPhone 3GS                        7-8%   70-80%    >90% (peak 98%)    48-62%    7-8%
  iPad 2, landscape                 2-4%   30%       >60% (peak 74%)    20-27%    2-4%
CALayer with pre-rendered CGLayers and animations (build from commit 4ea840c51f7307519fd54f1dca735c8e496b3371)
  iPhone 3GS                        7-8%   30-38%    >95% (peak 100%)   58-80%    7-8%
  iPad 2, landscape                 2-5%   15-25%    >60% (peak 68%)    27-36%    2-4%
CALayer with pre-rendered CGLayers, no animations (build from commit a29292250c102646335c9253bbccfbd1b13ab4fa)
  iPhone 3GS                        7-9%   16-26%    73-89% (peak 92%)  33-53%    6-8%
  iPad 2, landscape                 2-5%   9-15%     49-55%             15-22%    2-5%


Layers in their order of stacking
- Grid
  - This layer draws the grid lines on whose intersections stones are placed
- Coordinates
  - This layer draws the grid coordinate labels (A-T, 1-19)
  - This layer could possibly be merged with the grid layer
- Star Points
  - This layer marks up special intersections called star points (or hoshi, to
    use the Japanese term)
  - This layer could possibly be merged with the grid layer
- Cross-hair lines
  - This layer draws the cross-hair lines that indicate to the user during stone
    placement where the stone would be placed
  - This layer must be drawn at a different y-position than the cross-hair
    stone layer because normal stones should paint over cross-hair lines
- Stones
  - This layer draws the stones that have been placed during the current game
- Cross-hair stone
  - This layer draws the cross-hair stone that indicates to the user during
    stone placement where the stone would be placed
  - This layer cannot be at the top of the stack because we want symbols to be
    drawn on top of the cross-hair stone
- Symbols
  - This layer draws various symbols to mark up stones
  - Examples are: Last move, move numbers
  - This layer is hidden in Scoring mode
- Territory
  - This layer marks up territory in Scoring mode
  - This layer is shown only in Scoring mode
- Dead stones
  - This layer marks up dead stones in Scoring mode
  - This layer is shown only in Scoring mode


Events                                   Affected layer       Required change
----------------------------------------------------------------------------------
MarkLastMoveChanged                      Symbols              0-1 rectangles for the last stone that was placed
DisplayCoordinatesChanged                iPad: Coordinates    4 rectangles on all board sides that contain the labels
                                         iPhone: All layers   On iPhone we must resize the board
DisplayMoveNumbersChanged                Symbols              0-n rectangles, one for each stone that is placed
InconsistentTerritoryMarkupTypeChanged   Territory            Entire layer
CrossHairChanged                         Cross-hair           A set of rectangles to remove the old and draw the new cross-hair
GoGameDidCreate                          All layers           Entire layers (a new game might include a board size change)
playViewBoardPositionChanged             Stones               1-n rectangles, for a stone being placed + stones being captured/replaced
                                         Symbols              Update last move marker
GoScoreScoringEnabled                    Symbols              Hide layer
                                         Territory            Show layer
                                         Dead Stones          Show layer
GoScoreScoringDisabled                   Symbols              Show layer
                                         Territory            Hide layer
                                         Dead Stones          Hide layer
GoScoreCalculationEnds                   Territory            Update entire layer
                                         Dead Stones          Update entire layer
InterfaceRotationChanged                 All layers           Update entire layer (space available for drawing changes)

(note that this table may no longer be up-to-date)


Memory usage after adding zooming
---------------------------------
The following measurements were taken with the "Activity Monitor" instrument for
a release build on an iPhone 3GS. Unless otherwise noted (towards the end of
the table), measurements were taken while running a human vs. human game, with
the default GTP engine profile configured to have pondering disabled; in other
words: Fuego didn't use up any memory.

Memory usage   Situation
----------------------------------------------------
47.38 MB       After application launch, empty 19x19 board
50.18 MB       While panning around the board
50.38 MB       After placing the first stone
52.16 MB       After starting a new 19x19 game
53.79 MB       While panning around the board
51.49 MB       After placing the first stone
52.25 MB       After starting a new 19x19 game
53.88 MB       While panning around the board
51.55 MB       After placing the first stone
51.89 MB       After switching to the Archive tab
51.53 MB       After loading the Ear-redding game (325 moves on a 19x19 board)
53.93 MB       While panning around the board
54.61 MB       After zooming in to the maximum zoom scale (3.0)
77.02 MB       While panning around the zoomed part of the board. Memory usage
               remains at this value even after cancelling the gesture.
62.21 MB       After scrolling around for a while, memory usage suddenly drops
               to this value.
76.45 MB       While panning around another zoomed part of the board.
62.20 MB       Memory usage drops to this value on its own, i.e. I don't have
               to do any scrolling.
49.98 MB       After zooming out to normal zoom scale (1.0)
52.52 MB       After starting a new 19x19 game
52.60 MB       After zooming in to the maximum zoom scale (3.0)
74.27 MB       While panning around the zoomed part of the board
60.29 MB       Memory usage drops to this value on its own after placing the
               stone and waiting for some time
50.16 MB       After zooming out to normal zoom scale (1.0)
53.20 MB       After zooming in to the maximum zoom scale (3.0)
51.61 MB       Place a few stones while zoomed in, then zoom out, then zoom in
               again, scroll and wait a few moments
50.73 MB       After loading the Ear-reddening game, then zooming in to zoom
               scale 1.5 (double-tap)
55.30 MB       While panning at zoom scale 1.5
51.98 MB       After zooming in to zoom scale 2.25 (double-tap)
64.03 MB       While panning at zoom scale 2.25
89.17 MB       This value is the last sample taken before the app crashes. The
               setup that leads to the crash: Default profile settings (i.e.
               32 MB memory for Fuego, pondering enabled), Ear-reddening game
               loaded, zoom in to zoom scale 3.0.
110.19 MB      Same setup, this time the app does not crash, even while panning
               at zoom scale 3.0.

Additional measurements
- Similar actions with a 9x9 board yield roughly the same memory usage
- Memory usage with the maximum setup on other devices
  - iPhone 4S (retina display): 115.20 MB
  - iPad 2nd generation (normal display): 103.36
- Memory usage on iPhone 3GS after coordinate labels were implemented
  - When the labels are not visible at zoom scale 1.0, memory usage is about the
    same as before
  - When zoomed in to the maximum zoom scale 3.0, an additional 1 MB of memory
    is used
- Memory usage on iPhone 3GS, with coordinate labels at maximum zoom scale 3.0,
  but without the wooden background image
  - When Fuego does not use any memory: An additional 2 MB of memory is used.
  - When Fuego is pondering and has 32 MB memory at its disposition: The app
    uses 11 MB of memory less.

Conclusions
- The board size is not relevant, but the view size is
- It also doesn't matter much whether or not any stones are on the board
- Zooming in to the maximum zoom scale (3.0) is relatively cheap (~ 2-3 MB)
- Having a retina display is also less expensive than expected: A mere
  additional ~5 MB when compared to the normal display.
- The most expensive operation is panning at high zoom scales (~ 22-23 MB at
  zoom scale 3.0). Memory usage drops dramatically when panning at medium zoom
  scales, but is still significant (~ 5 MB at zoom scale 1.5, ~ 12 MB at zoom
  scale 2.25).
- The iPhone 3GS behaves somewhat erratically: Once the app crashed when it
  merely used 89 MB of memory, the second time everything worked well even when
  the app used a generous 110 MB. It can probably be said that the iPhone 3GS,
  and with it all the other devices that only have 256 MB RAM (iPad 1st
  generation, iPod Touch 3rd and 4th generation) are a bit overtaxed when the
  app's memory consumption suddenly jumps up by 25-40 MB. Newer devices,
  however, should be fine since they all have 512 MB RAM or more (cf. [1]).
- The numbers regarding the wooden background image contradict each other.
  Another measurement should be made where it is possible to dynamically turn
  on/off the background image, i.e. without having to recompile the app.

[1] https://en.wikipedia.org/wiki/List_of_iPhone_models


Redesigning the drawing mechanism to use tiling (v1.1.0)
--------------------------------------------------------
With zooming and scrolling, there are two conflicting forces:
- CPU usage
- Memory usage

CPU usage                Memory usage
   |----------------------------|
                       ^
        ^              Target state
        Current state

Current state
- Memory usage is as bad as it can get: After a zoom operation the maximum
  amount of memory is used.
- CPU usage, however, is almost optimal: After a zoom operation the entire
  scrollable content is rendered exactly once. In a subsequent scrolling
  operation, the system only needs to display the visible part of the
  pre-rendered bitmap.
- One flaw in regard to CPU usage is that if only a small thing changes about
  a layer, the entire layer needs to be rendered again - even if the change
  occurs outside of the currently visible area
- On the other hand, a layer that does not change never needs to be rendered
  again

The other extreme
- We could try to render exactly that part of the board that is currently
  visible
- Memory usage would be optimal in this scenario
- CPU usage, however, would be as bad is can get: The entire visible area would
  need to be rendered again after every scrolling operation - even if the user
  were to scroll only 1 pixel

Target state
- We aim at a target state that is at neither end of the scale, but somewhere
  in between: Tiling.
- Smaller tile sizes require less memory because there is not much rendered
  content that is outside of the currently visible area. In return, CPU usage
  increases because the system continually needs to render many small tiles
  when a scrolling operation occurs.
- In a first implementation, we use only a single hard-coded tile size that we
  experimtenally determine to strike a good balance. Later implementations can
  then try to calculate a dynamic tile size that is optimized for the device.

Tile reuse
- When a tile is no longer displayed, its view is not deallocated but placed
  into an internal reuse queue
- When a new tile needs to be displayed, the tiling implementation first tries
  to take a view from the queue before it allocates a new view instance
- This reuse mechanism sacrifices a bit of memory for more stable performance
  during scrolling. Measurements taken with the "Activity Monitor" on an iPad 2,
  with full zoom and wild scrolling
  - With tile reuse, CPU usage is between 57-73%
  - Without tile reuse, CPU usage is between 65-82%; this does not look like
    much, but the average CPU usage is higher, and scrolling is noticeably less
    smooth.
- The reason for these effects is not clear, but since the additional memory
  usage is rather small, tile reuse is an absolute must


Memory usage after adding tiling
--------------------------------
Test setup
- Release build, iOS SDK 7.1
- Empty 19x19 board
- GTP engine not initialized
- Tile size = 128x128
- NSZombieEnabled = NO
- Device: iPhone 4S (retina display, running iOS 7.1.3)
- The metrics that were measured are "Resident size" and "Dirty size" in the
  "VM Tracker" instrument.
- The "Resident size" value is the one that the system is looking at when it
  needs to determine whether to terminate the app.
- The "Dirty size" value is interesting because this is the part of the
  "Resident size" memory that can't be evicted without terminating the app.
- The "VM Tracker" instrument is set up together with the "Allocations"
  instrument through the "Allocations" template. The "Allocations"
  instrument adds a 32 MB chunk of "Performance tool data", so for more
  realistic numbers all measured values should be reduced by 32.


               | No Tiling |                        With Tiling                        | Action
               |           +-----------------------------------------------------------+
               |           | No             Cross-hair     Layer merge +    Coordinate |
               |           | optimization   optimization   dynamic layers   labels     |
---------------+-----------+-----------------------------------------------------------+---------------------------------
Resident size  | 112.93 MB | 122.63 MB      121.18 MB      111.16 MB                   | After application launch, empty 19x19 board
Dirty size     |  56.10 MB |  67.09 MB       67.10 MB       53.37 MB                   |
Resident size  |           |                130.80 MB      122.18 MB                   | Panning around the board
Dirty size     |           |                 76.58 MB       63.39 MB                   |
Resident size  | 168.75 MB | 124.99 MB      141.47 MB      116.73 MB                   | After zooming in to the maximum zoom scale (3.0)
Dirty size     | 129.84 MB |  75.50 MB       81.12 MB       58.96 MB                   |
Resident size  | 202.08 MB | 135.09 MB      142.54 MB      124.47 MB                   | While panning around the zoomed part of the board
Dirty size     | 169.55 MB |  88.03 MB       88.18 MB       66.69 MB                   |
Resident size  | 162.64 MB | 122.90 MB      130.36 MB      111.64 MB                   | After cancelling the gesture and waiting a few seconds
Dirty size     | 130.00 MB |  75.84 MB       75.98 MB       53.81 MB                   |
Resident size  |           |                               141.21 MB                   | Scrolling around the zoomed board
Dirty size     |           |                                83.33 MB                   |
                                                        

Some observations
- With tiling, no optimization
  - Memory usage rises only a little when zooming (resident memory ca. 2%,
    or less than 2.5 MB)
  - When panning, memory usage rises more (resident memory ca. 8%, or
    slightly more than 10 MB), but still significantly less than the
    no-tiling implementation
- No tiling
  - Memory usage rises massively when zooming (resident memory almost 50%,
    or 56 MB)
  - When panning, memory usage rises not as much as for the initial zoom,
    but still significantly (resident memory another 20%, or 33 MB)
- "No tiling" vs. "With tiling, no optimization"
  - At the peak, the tiling implementation uses about 67% of the resident
    memory of the no-tiling implementation
  - If we compare the "dirty size" instead of the "resident size" metric,
    then the impact of tiling becomes even more drastic. At the peak, the
    tiling implementation uses only about 52% of the memory of the
    no-tiling implementation. In terms of growth, tiling memory grows about
    31% while no-tiling grows a whopping 202%.
- "No tiling" vs. "With tiling, layer merge + dynamic layers"
  - Peak resident memory: Tiling implementation uses 62% of the resident
    memory of the no-tiling implementation
  - Peak dirty memory: Tiling implementation uses 40% of the dirty memory
    of the no-tiling implementation. Tiling memory grows about 25%.
- With tiling, no optimization: Not yet clear is why this requires more
  memory after application launch, i.e. while not zoomed in
  - A theory was that tiling generates a certain overhead because some
    tiles at the right and bottom edge of the board are unnecessarily large
  - The attempt at proving this theory was inconclusive, though
  - I tried to reduce the tile size so that the overhead also reduces
  - This did not fully work, though: With smaller tile sizes the initial
    "resident size" grew instead of becoming smaller (ca. 124 MB instead of
    122 MB, both for 64x64 and 32x32 tile sizes)
  - The "dirty size" value, though, improved (ca. 66.5 MB instead of
     67 MB, again for both 64x64 and 32x32 tile sizes)
  - Still, the difference to the no-tiling implementation is too large
    for it to come only from the pixel overhead at the right and bottom
    edge of the board. So this mystery has not been solved yet.

Some observations regarding Instruments
- I don't use the "Activity Monitor" instrument anymore because I don't
  understand the meaning of its measured values. Originally I tried to look
  at the "Real Mem" value, but this value is ridiculously low, so despite
  its name it certainly does not represent what I am interested in.
- I also don't use the "Allocations" instrument for this measurement,
  because the "Live Bytes" value is also extremely low. If an object is
  allocated, it may hold a reference to a much larger chunk of memory that
  is not accounted for by "Live Bytes", but is only visible in the
  "VM Tracker" instrument in the "Resident size" value.

Some observations that I made at one point using the "Allocations"
instrument when looking at the stones layer on an iPad 2nd generation
(i.e. non-Retina display):
- 128x128 tile size
  - 36 layer instances
  - 1 layer = 68 KB
  - 36 layers = 2448 KB = 2.39 MB
  - layer size = 16'384 pixel
- 256x256 tile size
  - 9 layer instances
  - 1 layer = 260 KB
  - 9 layers = 2340 KB = 2.29 MB
  - layer size = 65'536 pixel
- Layer overhead
  - 49'152 pixel more than the 128x128 tile
  - 192 KB more than the 128x128 tile
  - 49'152 pixel = 192 KB = 196'608 Bytes
  - 1 pixel = 4 Bytes
  - 65'536 pixel * 4 Bytes = 262'144 Bytes = 256 KB
  - Overhead per layer = 260 KB - 256 KB = 4 KB


CPU usage with tiling
---------------------
Test setup
- Release build, iOS SDK 7.1
- Empty 19x19 board
- GTP engine not initialized
- Tile size = 128x128
- NSZombieEnabled = NO
- Devices, all running iOS 7.1.3.
  - iPhone 4S (retina display)
  - iPad 2nd generation (normal display, portrait)
- The metric that was measured is "Total Load" of the system in the
  "Activity Monitor" instrument.


Sample 1: Initial tiling implementation without any optimizations

                iPhone 4S     iPad 2nd generation     Action
-----------------------------------------------------------------------------------------------------------
Total Load      63%           -                       During application launch, empty 19x19 board
Total Load      58-100%       -                       Panning around the board
Total Load      50%           -                       Zooming in to the maximum zoom scale (3.0)
Total Load      83-94%        -                       Panning around the zoomed part of the board
Total Load      50-96%        -                       Scrolling around the zoomed board
Total Load      63-81%        -                       Zooming out to the minimum zoom scale (1.0)

Sample 2: After optimizing cross-hair line + stone layers so that only those tiles are drawn that actually change

                iPhone 4S     iPad 2nd generation     Action
-----------------------------------------------------------------------------------------------------------
Total Load      63%           -                       During application launch, empty 19x19 board
Total Load      58-65%        -                       Panning around the board
Total Load      41%           -                       Zooming in to the maximum zoom scale (3.0)
Total Load      55-70%        -                       Panning around the zoomed part of the board
Total Load      55-77%        -                       Scrolling around the zoomed board
Total Load      44-98%        -                       Zooming out to the minimum zoom scale (1.0)

Sample 3: After optimizing by merging layers + dynamically turning layers on/off

                iPhone 4S     iPad 2nd generation     Action
-----------------------------------------------------------------------------------------------------------
Total Load      79%           -                       During application launch, empty 19x19 board
Total Load      62-72%        -                       Panning around the board
Total Load      34%           -                       Zooming in to the maximum zoom scale (3.0)
Total Load      53-57%        -                       Panning around the zoomed part of the board
Total Load      47-55%        -                       Scrolling around the zoomed board
Total Load      66-81%        -                       Zooming out to the minimum zoom scale (1.0)


Memory usage on iPad 2 with different tile sizes
------------------------------------------------
Test setup
- Release build, iOS SDK 7.1
- Empty 19x19 board (9x9 in the first measurement)
- GTP engine not initialized
- Coordinate labels + influence enabled
- NSZombieEnabled = NO
- Device: iPad 2 (no retina display, running iOS 7.1.3)


               | 9x9 board |            19x19 boards           |
               | 128 x 128 | 128 x 128   256 x 256    64 x 64  | Action
---------------+-----------+-----------------------------------+---------------------------------
Resident size  | 112.94 MB | 107.37 MB   108.68 MB   109.14 MB | After application launch, empty 19x19 board
Dirty size     |  54.20 MB |  54.29 MB    54.44 MB    54.36 MB |
Resident size  | 117.29 MB | 116.89 MB   119.50 MB   115.23 MB | Panning around the board
Dirty size     |  63.28 MB |  65.59 MB    67.45 MB    62.23 MB |
Resident size  | 109.27 MB | 110.19 MB   111.93 MB   109.73 MB | After zooming in to the maximum zoom scale (3.0)
Dirty size     |  56.75 MB |  58.91 MB    59.90 MB    58.37 MB |
Resident size  | 119.66 MB | 122.12 MB   126.05 MB   120.05 MB | While panning around the zoomed part of the board
Dirty size     |  67.13 MB |  70.83 MB    74.06 MB    68.64 MB |
Resident size  | 107.68 MB | 107.79 MB   110.19 MB   103.88 MB | After cancelling the gesture and waiting a few seconds
Dirty size     |  55.15 MB |  56.50 MB    58.19 MB    56.97 MB |
Resident size  | 127.04 MB | 123.53 MB   133.04 MB   115.84 MB | Scrolling around the zoomed board
Dirty size     |  74.53 MB |  72.27 MB    81.04 MB    68.62 MB |

Observations
- Smaller tile size = generally lower memory consumption
- 9x9 vs. 19x19 board: Difficult to say what the difference is
- Smaller tiles = generally higher CPU% / lower fps rate
  - 64x64
    - Zoomed out = 28-29 fps
    - Zoomed in = 21-24 fps
  - 128x128
    - Zoomed out = 54-59 fps
    - Zoomed in = 33-42 fps
  - 256x256
    - Zoomed out = 57-60 fps
    - Zoomed in = 40-48 fps
  - Measurements made with Core Animation instrument while panning
  - At 64x64 the low fps frate is noticeable, the CPU is almost constantly
    at 100%
- For iPad 2, 128x128 tile size seems a good medium value


Application launch times when restoring from NSCoding archive
-------------------------------------------------------------
The following measurements were taken with the "Time Profiler" instrument for
a release build on an iPhone 3GS and an iPad 2. For each measurement, 3 values
were recorded:

1. GtpEngine startup: How much time did it take for the GtpEngine main loop to
   start up. This includes how much time it takes for Fuego to set up its
   internals. Because the GtpEngine main loop runs in a secondary thread, this
   time cannot be simply added to the other times to get at the full application
   launch time as perceived by the user. There is a certain amount of
   parallelism involved, which mainly depends on the capabilities of the
   device's processor.
2. UIApplication launch: How much time did it take for iOS to complete the
   launch cycle of the UIApplication main object. This number excludes the
   GtpEngine startup time (runs in parallel) and the SetupApplicationCommand
   execution time (runs after the UIApplication launch). Significant portions
   of the UIApplication launch time are:
   1) Loading of the main .nib file
   2) Some initial GUI stuff that I cannot identify any closer but which seems
      to have to do with a CoreAnimation transaction
   3) Creating the status bar
   4) Running the app delegate method application:didFinishLaunchingWithOptions:
   5) Running the app delegate method applicationDidBecomeActive:
3. SetupApplicationCommand: How long did it take for this command to execute.
   The significant part is, of course, RestoreGameCommand, whose respective
   significant portions are:
   1) Decoding the NSCoding archive
   2) Executing NewGameCommand

                                |               iPhone 3GS                     |               iPad 2
                                |  GtpEngine  UIApplication  SetupApplication  |  GtpEngine  UIApplication  SetupApplication
                                |  startup    launch         Command           |  startup    launch         Command
--------------------------------+----------------------------------------------+--------------------------------------------
Measurement 1                   |  2924 ms    1179 ms        62 ms             |  1312 ms    340 ms         27 ms
(19x19 game, only 1 move,       |                                              |
Fuego with playing strength 1)  |                                              |
                                |                                              |
Measurement 2                   |  3256 ms    1169 ms        157 ms            |  1540 ms    733 ms         69 ms
(ear-reddening game,            |                                              |
Fuego with playing strength 1)  |                                              |
                                |                                              |
Measurement 3                   |  3308 ms    1171 ms        156 ms            |  1541 ms    714 ms         67 ms
(ear-reddening game,            |                                              |
Fuego with playing strength 5)  |                                              |
                                |                                              |
Measurement 4                   |  3313 ms     999 ms        158 ms            |  1540 ms    432 ms         68 ms
(ear-reddening game,            |                                              |
Fuego with playing strength 1,  |                                              |
no HUD)                         |                                              |


The times for measurement 1 for the iPhone 3GS have been broken down a bit so
that the impact of certain setup tasks can be gauged:

- UIApplication launch, total time = 1179 ms
  - Loading of the main .nib file              = 256 ms
  - Some initial GUI stuff                     = 307 ms
  - Creating the status bar                    =  95 ms
  - application:didFinishLaunchingWithOptions: = 155 ms
    - setupCrashReporting = 79 ms
    - setupUserDefaults   = 23 ms
    - setting up the HUD  = 21 ms
  - applicationDidBecomeActive:                =  17 ms
    (the main part here is used up by ArchiveViewModel's updateGameList)
- SetupApplicationCommand, total time = 62 ms
  - Decoding the NSCoding archive = 29 ms
  - Executing NewGameCommand      = 13 ms
  - Other stuff                   = 12 ms

The conclusions:
- Restoring from an NSCoding archive is a huge leap forward. The time previously
  spent on loading the backup .sgf file, and restoring the board position
  (several seconds), has been reduced to a quite insignificant portion of the
  overall launch time. Even under the worst circumstances (large game in
  progress, slowest device), decoding the NSCoding archive and executing
  SetupApplicationCommand now takes less than 160 ms.
- A major factor contributing to the app launch time is the time it takes for
  Fuego to set up. There is not much that we can do here, but take comfort in
  the next observation...
- Device capabilities dramatically reduce launch time

All in all it can probably be said that the application launch problem has
been virtually eliminated, and that further time and effort for optimizing
should therefore be spent in other areas.


The Smart Game Format (SGF)
---------------------------
Overview
- The SGF specification lives here: https://www.red-bean.com/sgf/index.html
- The formal EBNF definition can be found here: https://www.red-bean.com/sgf/sgf4.html#2
- The current version is SGF FF[4].
- Discussions on a new version SGF FF [5] and on an XML format XGF that will
  replace SGF were started in 1999 and 2002, respectively, but to date no
  progress has been made.
- The format is usable for all kinds of board games. Game-specific extensions
  exist, specifically for Go.

Structure
- An SGF document consists of nodes structured in a tree.
- A node has 1 predecessor: Its parent.
- A node has 0-n successors: Its children.

Nodes
- A node consists of 1-n properties

Move properties vs. setup properties
- A node can contain 0-n setup properties
- A node can contain 0-1 move properties
- A node cannot contain both setup and move properties at the same time


Example tree, shown in the simplified Go convention:

root -- A -- B -- C
   \          \
   \          -- D -- E
   -- F -- G -- H -- I
   \
   -- J

The same example tree, shown in purely hierarchical form:

root
+-- A
|   +-- B
|       +-- C
|       +-- D
|           +-- E
+-- F
+-- G
|   +-- H
|       +-- I
+-- J


The same example tree, shown in annotated SGF format. The annotations use terms
from the EBNF definition of the SGF format.

game          game       game
tree 1        tree 2     tree 3
v             v          v
(;FF[4]C[root](;C[a];C[b](;C[c])
game
tree 4
v
(;C[d];C[e]))
game  game
tree 5tree 6
v     v
(;C[f](;C[g];C[h];C[i])
game
tree 7
v
(;C[j])))
